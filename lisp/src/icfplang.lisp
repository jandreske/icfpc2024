(defpackage :icfplang
  (:use :cl)
  (:import-from :alexandria :array-index :array-length)
  (:export :icfp->ascii :ascii->icfp :parse-program :encode :eval-icfp))


(in-package :icfplang)

(defvar +to-ascii+
  (concatenate 'string
	       "abcdefghijklmnopqrstuvwxyz"
	       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	       "0123456789"
	       "!\"#$%&'()*+,-./:;<=>?@[\\]^_`|~ "
	       (string #\newline)))

(defconstant +max-reductions+ 10000000)

(declaim (inline atomp))
(defun atomp (e)
  (not (consp e)))

(defun icfp->ascii (s)
  (if (stringp s)
      (map 'string #'(lambda (c) (char +to-ascii+ (- (char-int c) 33))) s)
      s))

(defun ascii->icfp (s)
  ;; TODO: use table lookup
  (map 'string #'(lambda (c) (code-char (+ 33 (position c +to-ascii+)))) s))

(defun unop (c)
  (ecase c
    (#\- 'negate)
    (#\! 'not)
    (#\# 'string->int)
    (#\$ 'int->string)))

(defun binop (c)
  (ecase c
    (#\$ 'apply)
    (#\+ '+)
    (#\- '-)
    (#\* '*)
    (#\/ '/)
    (#\% '%)
    (#\< '<)
    (#\> '>)
    (#\= '=)
    (#\| 'or)
    (#\& 'and)
    (#\. 'concat)
    (#\T 'take)
    (#\D 'drop)))

(defun encode-token (tag)
  (ecase tag
    (apply "B$")
    (if "?")
    (negate "U-")
    (not "U!")
    (string->int "U#")
    (int->string "U$")
    (+ "B+")
    (- "B-")
    (* "B*")
    (/ "B/")
    (% "B%")
    (< "B<")
    (> "B>")
    (= "B=")
    (or "B|")
    (and "B&")
    (concat "B.")
    (take "BT")
    (drop "BD")))
    

(defun encode-expr (e)
  (typecase e
    (string (concatenate 'string "S" e))
    (number (concatenate 'string "I" (int-to-string e)))
    (null "F")
    (cons
     (case (car e)
       (lambda (concatenate 'string "L" (int-to-string (cadr e)) " " (encode-expr (caddr e))))
       (var (concatenate 'string "v" (int-to-string (cadr e))))
       (t 
	(apply concatenate 'string (encode-token (car e))
	       (mapcar #'encode-expr (cdr e))))))
    (t "T")
    ))

(defun encode (program)
  (apply #'concatenate 'string (mapcar #'encode-expr program)))

(defun self-evaluating-p (expr)
  (declare (optimize speed))
  (or (atomp expr)
      (eq (car expr) 'lambda)
      (eq (car expr) 'var)))

(declaim (ftype (function (integer) string) int-to-string))
(defun int-to-string (n)
  (labels ((build (s n)
	     (if (zerop n)
		 (coerce s 'string)
		 (multiple-value-bind (q r)
		     (truncate n 94)
		   (build (cons (code-char (+ r 33)) s)
			  q)))))
    (if (zerop n)
	"!"
	(build nil n))))
		 

(declaim (ftype (function (string array-index)
			  (values (integer 0 *) array-length))
		parse-int))
(defun parse-int (s i)
  (labels ((accum (len i n)
	     (declare (optimize speed))
	     (declare (type array-length len i)
		      (type (integer 0 *) n))
	     (if (>= i len)
		 (values n i)
		 (let ((c (char s i)))
		   (if (char<= c #\space)
		       (values n (+ i 1))
		       (accum len
			      (+ i 1)
			      (+ (* 94 n) (- (char-int c) 33))))))))
    (accum (length s) i 0)))

(declaim (ftype (function (string) t)
		parse-program))
(defun parse-program (s)
  (let ((end (length s)))
    (declare (type array-length end))
    (labels ((parse (i)
	       (declare (type array-length i))
	       (when (>= i end)
		 (error "attempt to parse beyond end of program ~S" i))
	       (ecase (char s i)
		 ((#\space #\newline) (parse (+ i 1)))
		 (#\F (values nil (+ i 1)))
		 (#\T (values t (+ i 1)))
		 (#\I (parse-int s (+ i 1)))
		 (#\S (let ((p (position #\space s :start (+ i 1))))
			(values (subseq s (+ i 1) p)
				(if p p end))))
		 (#\U (multiple-value-bind (e k)
			  (parse (+ i 3))
			(values (list (unop (char s (+ i 1))) e) k)))
		 (#\B (multiple-value-bind (e1 k1)
			  (parse (+ i 3))
			(multiple-value-bind (e2 k2)
			    (parse k1)
			  (values (list (binop (char s (+ i 1))) e1 e2) k2))))
		 (#\? (multiple-value-bind (e1 k1) (parse (+ i 1))
			(multiple-value-bind (e2 k2) (parse k1)
			  (multiple-value-bind (e3 k3) (parse k2)
			    (values (list 'if e1 e2 e3) k3)))))
		 (#\L (multiple-value-bind (v k)
			  (parse-int s (+ i 1))
			(multiple-value-bind (body k2)
			    (parse k)
			  (values (list 'lambda v body) k2))))
		 (#\v (multiple-value-bind (v k)
			  (parse-int s (+ i 1))
			(values (list 'var v) k))))))
      (multiple-value-bind (e k)
	  (parse 0)
	(if (= k end)
	    e
	    (error "incomplete parse: ~S of ~S" k end))))))


(defun eval-icfp (e)
  (let ((betas 0))
    (declare (type (integer 0 100000000) betas))
    (declare (optimize (speed 2)))
    (labels ((evaluate (e)
	       (do ((e e (eval1 e)))
		   ((self-evaluating-p e) e)))
	     (eval1 (e)
	       (declare (optimize (speed 2)))
	       (ecase (car e)
		 (if (if (evaluate (cadr e))
			 (caddr e)
			 (cadddr e)))
		 (negate (- (evaluate (cadr e))))
		 (not (not (evaluate (cadr e))))
		 (string->int
		  (let ((s (evaluate (cadr e))))
		    (multiple-value-bind (n e)
			(parse-int s 0)
		      (declare (ignore e))
		      n)))
		 (int->string
		  (int-to-string (evaluate (cadr e))))
		 (apply
		  (eval-apply (evaluate (cadr e)) (caddr e)))
		 (+ (+ (evaluate (cadr e)) (evaluate (caddr e))))
		 (- (- (evaluate (cadr e)) (evaluate (caddr e))))
		 (/ (truncate (evaluate (cadr e))
			      (evaluate (caddr e))))
		 (% (multiple-value-bind (q r)
			(truncate (evaluate (cadr e))
				  (evaluate (caddr e)))
		      (declare (ignore q))
		      r))
		 (< (< (evaluate (cadr e)) (evaluate (caddr e))))
		 (> (> (evaluate (cadr e)) (evaluate (caddr e))))
		 (= (equal (evaluate (cadr e)) (evaluate (caddr e))))
		 (or (or (evaluate (cadr e)) (evaluate (caddr e))))
		 (and (and (evaluate (cadr e)) (evaluate (caddr e))))
		 (concat (concatenate 'string
				      (evaluate (cadr e))
				      (evaluate (caddr e))))
		 (take (subseq (evaluate (caddr e))
			       0
			       (evaluate (cadr e))))
		 (drop (subseq (evaluate (caddr e))
			       (evaluate (cadr e))))))
	     (strict-eval (e)
	       (if (and (consp e)
			(member (car e) '(+ - * / % < > = concat))
			(atomp (cadr e))
			(atomp (caddr e)))
		   e ; (eval1 e)
		   e))
	     (eval-apply (f a)
	       (declare (optimize (speed 2)))
	       (if (eq (car f) 'lambda)
		   (progn (incf betas)
			  (substit (cadr f) (strict-eval a) (caddr f)))
		   (error "B$: lambda expected, but got ~S" f))))
      (let ((val (evaluate e)))
	(values val betas)))))

(defun substit (var val e)
  (declare (type (integer 0 *) var))
  (labels ((sub (e)
	     (if (atomp e)
		 e
		 (case (car e)
		   (var (if (= var (cadr e)) val e))
		   (if (cons 'if (mapcar #'sub (cdr e))))
		   (lambda (if (= var (cadr e))
			       e
			       (multiple-value-bind (v1 b1)
				   (rename-if-free (cadr e) (caddr e) val)
				 (list 'lambda v1 (sub b1)))))
		   (t
		    (cons (car e)
			  (mapcar #'sub (cdr e))))))))
    (sub e)))

(defun rename-if-free (v body expr)
  (if (free-p v expr)
      (let ((v1 (+ (max-var expr) 1)))
	(values v1 (rename v v 1 body)))
      (values v body)))

(defun free-p (v e)
  (declare (type (integer 0 *) v))
  (if (atomp e)
      nil
      (case (car e)
	(var (= v (cadr e)))
	(lambda (and
		 (not (= v (cadr e)))
		 (free-p v (caddr e))))
	(if (or (free-p v (cadr e))
		(free-p v (caddr e))
		(free-p v (cadddr e))))
	(t (or (free-p v (cadr e))
	       (free-p v (caddr e)))))))

(defun max-var (e)
  (if (atomp e)
      -1
      (case (car e)
	(var (cadr e))
	(lambda (max (cadr e) (max-var (caddr e))))
	(if (max (max-var (cadr e))
		 (max-var (caddr e))
		 (max-var (cadddr e))))
	(t (max (max-var (cadr e))
		(max-var (caddr e)))))))

(defun rename (v v1 e)
  (if (atomp e)
      e
      (case (car e)
	(var (if (= v (cadr e)) (list 'var v1) e))
	(lambda (list 'lambda
		      (if (= v (cadr e)) v1 (cadr e))
		      (rename v v1 (caddr e))))
	(if (list 'if
		  (rename v v1 (cadr e))
		  (rename v v1 (caddr e))
		  (rename v v1 (cadddr e))))
	(t (cons (car e) (mapcar #'(lambda (e) (rename v v1 e)) (cdr e)))))))


