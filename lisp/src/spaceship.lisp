(defpackage :spaceship
  (:use :cl)
  (:import-from :alexandria :array-index)
  (:export :read-locations :solve))

(in-package :spaceship)

(defconstant +max-moves+ 10000000)

(deftype coord () '(signed-byte 32))

(defun read-locations (file)
  (with-open-file (s file :direction :input)
    (let ((locations nil))
      (declare (type list locations))
      (do ((n (read s nil) (read s nil)))
	  ((not (integerp n))
	   (let ((lcs (coerce locations '(simple-array coord (*)))))
	     (unless (evenp (length lcs))
	       (error "corrupted spaceship problem"))
	     (nreverse lcs)))
	(push n locations)))))


(declaim (ftype (function (coord coord coord coord) (unsigned-byte 24))
		manhattan-distance))
(declaim (inline manhattan-distance))
(defun manhattan-distance (x1 y1 x2 y2)
  (+ (abs (- x2 x1))
     (abs (- y2 y1))))

(defun galaxy-width (locations)
  (let ((lo (aref locations 0))
	(hi (aref locations 0))
	(n (length locations)))
    (do ((i 2 (+ i 2)))
	((>= i n) (1+ (- hi lo)))
      (let ((x (aref locations i)))
	(when (< x lo) (setf lo x))
	(when (> x hi) (setf hi x))))))

(defun galaxy-height (locations)
  (let ((lo (aref locations 1))
	(hi (aref locations 1))
	(n (length locations)))
    (do ((i 3 (+ i 2)))
	((>= i n) (1+ (- hi lo)))
      (let ((x (aref locations i)))
	(when (< x lo) (setf lo x))
	(when (> x hi) (setf hi x))))))


(declaim (ftype (function ((simple-array coord (*))
			   (simple-array bit (*))
			   coord coord)
			  (or null array-index))
		nearest-unvisited))

(defun nearest-unvisited (locations visited x y)
  (declare (type coord x y))
  (let ((pos nil)
	(dist 0)
	(n (length visited)))
    (declare (optimize speed))
    (declare (type (unsigned-byte 24) dist))
    (dotimes (i n)
      (when (zerop (aref visited i))
	(let ((d (manhattan-distance x y (aref locations (* i 2)) (aref locations (+ (* i 2) 1)))))
	  (when (or (null pos) (< d dist))
	    (setf dist d)
	    (setf pos i)))))
    pos))

(defun dist-to-motionless (velocity)
  (rem (* velocity (+ 1 velocity)) ;  2))
       4))



(defun reach (d v)
  (labels ((steps (d v)
	     (cond ((zerop v) 1000000000)
		   ((< d 0)    500000000)
		   ((< v 0)    250000000)
		   ((zerop d) 0)
		   (t
		 (let* ((d (- d v))
			(brake (steps d (- v 1)))
			(neutral (steps d v))
			(speedup (steps d (+ v 1))))
		   (1+ (min brake neutral speedup)))))))
    (let ((speedup (steps d ( + v 1)))
	  (neutral (steps d v))
	  (brake (steps d (- v 1))))
      (if (<= speedup neutral)
	  (if (<= speedup brake) 1
	      (if (<= neutral brake) 0 -1))
	  (if (<= neutral brake) 0 -1)))))

(declaim (ftype (function (list list) t) better))
(defun better (a b)
  (declare (optimize speed))
  (cond ((null a) t)
	((null b) nil)
	((symbolp (car a)) nil)
	((symbolp (car b)) t)
	(t (better (cdr a) (cdr b)))))

(declaim (ftype (function (coord coord) list) path))
(defun path (d v)
  (declare (optimize (speed 2)))
  (let ((d1 (- d v)))
    (cond ((= d 0) nil)
	  ((= v 0) '(ignore))
	  ((>= (abs d1) (abs d)) '(fail))
	  (t (let ((b (path d1 (- v 1)))
		   (n (path d1 v))
		   (s (path d1 (+ v 1))))
	       (if (better b n)
		   (if (better b s)
		       (cons -1 b)
		       (cons 1 s))
		   (if (better n s)
		       (cons 0 n)
		       (cons 1 s))))))))

(declaim (ftype (function (coord coord) (or null (integer -1 1))) best-accel))
(defun best-accel (d v)
  (let ((fail 1000000000))
    (labels ((step1 (d v)
	       (declare (type coord d v))
	       (let ((d1 (- d v)))
		 (cond ((= d 0) (values 0 1))
		       ((= v 0) (values fail 1))
		       ((>= (abs d1) (abs d)) (values fail 1))
		       (t (let ((cb (step1 d1 (- v 1)))
				(cn (step1 d1 v))
				(cs (step1 d1 (+ v 1))))
			    (if (<= cs cn)
				(if (<= cs cb)
				    (values (+ cs 1) 1)
				    (values (+ cb 1) -1))
				(if (<= cn cb)
				    (values (+ cn 1) 0)
				    (values (+ cb 1) -1)))))))))
      (multiple-value-bind (c a) (step1 d v)
	(if (>= c fail)
	    nil
	    a)))))



(declaim (ftype (function (coord coord coord)
			  (integer -1 1))
		accel))
(defun accel (target position velocity)
  (declare (optimize speed))
  ;; let's see what happens if we optimize some simple cases by hand
  (let ((delta (- target position)))
    (cond
      ((and (> delta 2) (= velocity (1+ (truncate delta 2)))) -1)
      ((and (< delta -2) (= velocity (floor delta 2))) 1)
      ((= delta velocity) 0)
      ((= delta (* 2 velocity)) 0)
      ((and (> delta 0) (<= delta (* 2 velocity))) -1)
      ((and (< delta 0) (>= delta (* 2 velocity))) 1)
      (t
       (let ((a (- target position velocity)))
	 (alexandria:clamp a -1 1))))))
    
(defparameter +keys+ #2a((#\1 #\4 #\7) (#\2 #\5 #\8) (#\3 #\6 #\9)))

(declaim (inline get-key))
(defun get-key (ax ay)
  (aref +keys+ (+ ax 1) (+ ay 1)))

(defun solve (locations)
  (declare (type (simple-array coord (*)) locations))
  (let ((x 0)
	(y 0)
	(vx 0)
	(vy 0)
	(max-vx (+ 3 (* 20 (floor (sqrt (galaxy-width locations))))))
	(max-vy (+ 3 (* 20 (floor (sqrt (galaxy-height locations))))))
	(visited (make-array (floor (length locations) 2)
			     :element-type 'bit
			     :initial-element 0))
	(num-moves 0)
	(moves nil))
    (declare (type coord x y vx vy)
	     (type (integer 0 100000000) num-moves)
	     (type list moves))
    ;; (format t "Galaxy size: ~ax~a. Max velocity: ~a,~a~%" (galaxy-width loctions) (galaxy-height locations) max-vx max-vy)
    (do ((dest-index (nearest-unvisited locations visited
					(+ x (dist-to-motionless vx))
					(+ y (dist-to-motionless vy)))
		     (nearest-unvisited locations visited
					(+ x (dist-to-motionless vx))
					(+ y (dist-to-motionless vy)))))
	((not dest-index) (coerce (nreverse moves) 'string))
      (do* ((dest-x (aref locations (* dest-index 2)))
	    (dest-y (aref locations (+ (* dest-index 2) 1))))
	   ((and (= x dest-x) (= y dest-y))
	    (setf (aref visited dest-index) 1))
	(let ((ax (accel dest-x x vx))
	      (ay (accel dest-y y vy)))
	  (push (get-key ax ay) moves)
	  (when (> num-moves +max-moves+)
	    (format t "~&Maximum number of moves reached!~%")
	    (return-from solve (coerce (nreverse moves) 'string)))
	  (incf num-moves)
	  (incf vx ax)
	  ;; (when (> (abs vx) max-vx)
	  ;;   (setf vx (if (> vx 0) max-vx (- max-vx))))
	  (incf vy ay)
	  ;; (when (> (abs vy) max-vy)
	  ;;   (setf vy (if (> vy 0) max-vy (- max-vy))))
	  (incf x vx)
	  (incf y vy)
	  )))))

