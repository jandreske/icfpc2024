(defpackage :spaceship
  (:use :cl)
  (:import-from :alexandria :array-index)
  (:export :read-locations :solve))

(in-package :spaceship)

(defconstant +max-moves+ 10000000)

(deftype coord () '(signed-byte 32))

(defun read-locations (file)
  (with-open-file (s file :direction :input)
    (let ((locations nil))
      (declare (type list locations))
      (do ((n (read s nil) (read s nil)))
	  ((not (integerp n))
	   (let ((lcs (coerce locations '(simple-array coord (*)))))
	     (unless (evenp (length lcs))
	       (error "corrupted spaceship problem"))
	     (nreverse lcs)))
	(push n locations)))))


(declaim (ftype (function (coord coord coord coord) (unsigned-byte 24))
		manhattan-distance))
(declaim (inline manhattan-distance))
(defun manhattan-distance (x1 y1 x2 y2)
  (+ (abs (- x2 x1))
     (abs (- y2 y1))))


(declaim (ftype (function ((simple-array coord (*))
			   (simple-array bit (*))
			   coord coord)
			  (or null array-index))
		nearest-to))

(defun nearest-unvisited (locations visited x y)
  (declare (type coord x y))
  (let ((pos nil)
	(dist 0)
	(n (length visited)))
    (declare (optimize speed))
    (declare (type (unsigned-byte 24) dist))
    (dotimes (i n)
      (when (zerop (aref visited i))
	(let ((d (manhattan-distance x y (aref locations (* i 2)) (aref locations (+ (* i 2) 1)))))
	  (when (or (null pos) (< d dist))
	    (setf dist d)
	    (setf pos i)))))
    pos))

(defun dist-to-motionless (velocity)
  (floor (* velocity (+ 1 velocity)) 2))

(declaim (ftype (function (coord coord coord)
			  (integer -1 1))
		accel))

(defun accel (target position velocity)
  (declaim (optimize speed))
  (let ((a (- target position velocity)))
    (alexandria:clamp a -1 1)))

(defparameter +keys+ #2a((#\1 #\4 #\7) (#\2 #\5 #\8) (#\3 #\6 #\9)))

(declaim (inline get-key))
(defun get-key (ax ay)
  (aref +keys+ (+ ax 1) (+ ay 1)))

(defun solve (locations)
  (let ((x 0)
	(y 0)
	(vx 0)
	(vy 0)
	(visited (make-array (floor (length locations) 2)
			     :element-type 'bit
			     :initial-element 0))
	(num-moves 0)
	(moves nil))
    (declare (type coord x y vx vy)
	     (type (integer 0 100000000) num-moves)
	     (type list moves))
    (do ((dest-index (nearest-unvisited locations visited
					(+ x (dist-to-motionless vx))
					(+ y (dist-to-motionless vy)))
		     (nearest-unvisited locations visited
					(+ x (dist-to-motionless vx))
					(+ y (dist-to-motionless vy)))))
	((not dest-index) (coerce (nreverse moves) 'string))
      (do* ((dest-x (aref locations (* dest-index 2)))
	    (dest-y (aref locations (+ (* dest-index 2) 1))))
	   ((and (= x dest-x) (= y dest-y))
	    (setf (aref visited dest-index) 1))
	(declaim (optimize speed))
	(let ((ax (accel dest-x x vx))
	      (ay (accel dest-y y vy)))
	  (push (get-key ax ay) moves)
	  (when (> num-moves +max-moves+)
	    (format t "~&Maximum number of moves reached!~%")
	    (return-from solve (coerce (nreverse moves) 'string)))
	  (incf num-moves)
	  (incf vx ax)
	  (incf vy ay)
	  (incf x vx)
	  (incf y vy)
	  )))))

